#pragma once
#include <JuceHeader.h>
#include <array>
#include <vector>
#include <complex>
#include <functional>
#include <algorithm>
#include <cmath>
#include <cstring>

//------------------------------------------------------------------------------
// GriffinFFT_UL - A flexible FFT engine with multiple modes:
//
//   (1) Real-time overlap-add usage (processSample, processBlock)
//   (2) A one-shot "processEntireBuffer" approach
//   (3) An offline STFT pipeline supporting advanced additive re-synthesis
//
// This version performs high-detail partial extraction and global tracking.
// The FFT is performed with high resolution (via zero-padding) and nearly all
// peaks are detected using quadratic interpolation. Then, a density-balancing
// stage divides the spectrum into three fixed bands (low, mid, high) and prunes
// peaks per band using fixed maximums (in the low band, maxLow is reduced to 2).
// Global greedy tracking then links peaks into continuous trajectories ("snakes")
// from the very first frame of appearance, so that rising partials are captured
// smoothly. An importance score is computed for each trajectory (with a slight boost
// for frequencies above 250 Hz) and only the top "maxPartials" trajectories are retained.
// These tracked partials are stored in a dedicated data structure (Trajectory) for
// later processing. Finally, each trajectory's (smoothed) amplitude and frequency
// envelopes are used for re-synthesis via linear interpolation with continuous phase
// integration and minimal fades (~5 ms) at its boundaries. The final output is then
// normalized to match the RMS level of the original signal.
//
// The parameter maxPartials (ranging from 3 to 200) is externally controlled and
// determines the maximum number of simultaneous partials to render.
//
// An additional constant, CULLING_LENIENCY, has been introduced to scale the
// effective threshold used for culling peaks. Adjust this constant to control
// the leniency of culling (lower values are more lenient, higher values cull more).
//------------------------------------------------------------------------------
class GriffinFFT_UL
{
public:
    //------------------------------------------------------------------------------
    // Constant for culling leniency.
    // Lower values (e.g., 0.5) will be more lenient (retain more peaks),
    // Higher values (e.g., 2.0) will be more aggressive.
    //------------------------------------------------------------------------------
    static constexpr float CULLING_LENIENCY = 0.5f;

    //==============================================================================
    // FFT / Overlap / Window Settings
    //==============================================================================
    static constexpr int fftOrder = 11;              // 2^11 = 2048
    static constexpr int fftSize = 1 << fftOrder;      // 2048 samples per frame
    static constexpr int overlap = 4;                  // 75% overlap
    static constexpr int hopSize = fftSize / overlap;  // 512 samples hop
    static constexpr int zeroPadOrder = fftOrder + 1;  // 2^(11+1) = 4096
    static constexpr int paddedSize = 1 << zeroPadOrder; // 4096 samples
    static constexpr int paddedNumBins = paddedSize / 2 + 1;
    static constexpr float windowCorrection = 2.0f / 3.0f; // Correction factor for Hann^2

    //==============================================================================
    // Public Parameter Setters
    //==============================================================================
    inline void setSampleRate(float sr) { currentSampleRate = sr; }
    inline void setLowpassCutoff(float freqHz) { lowpassCutoffFrequency = freqHz; }
    // additivePeakThreshold is the base threshold for starting a new partial.
    inline void setAdditivePeakThreshold(float thresh) { additivePeakThreshold = thresh; }
    // maxPartials sets the maximum number of partials to track (from 3 to 200).
    inline void setMaxPartials(int m) { maxPartials = std::max(3, std::min(m, 200)); }

    //==============================================================================
    // Constructor
    //==============================================================================
    GriffinFFT_UL()
        : fft(fftOrder),
        fftPadded(zeroPadOrder),
        currentSampleRate(44100.0f),
        lowpassCutoffFrequency(5000.0f),
        additivePeakThreshold(0.5f),
        maxPartials(60),   // Default maximum partials.
        pos(0),
        count(0)
    {
        windowTable.resize(fftSize);
        compositeWindow.resize(fftSize);
        for (int i = 0; i < fftSize; ++i)
            windowTable[i] = 0.5f * (1.0f - std::cos((2.0f * 3.14159265358979323846f * i) / (fftSize - 1)));
        for (int i = 0; i < fftSize; ++i)
            compositeWindow[i] = windowTable[i] * windowTable[i] * windowCorrection;
        inputFifo.fill(0.0f);
        outputFifo.fill(0.0f);
        fftData.resize(fftSize * 2, 0.0f);
        paddedData.resize(paddedSize * 2, 0.0f);
    }

    //==============================================================================
    // reset
    //==============================================================================
    inline void reset()
    {
        count = 0;
        pos = 0;
        inputFifo.fill(0.0f);
        outputFifo.fill(0.0f);
    }

    //==============================================================================
    // 1) Real-time Overlap-Add Usage (unchanged)
    //==============================================================================
    inline void processBlock(const float* inBlock, float* outBlock, int numSamples, bool bypassed)
    {
        int i = 0;
        while (i < numSamples)
        {
            int localPos = pos;
            int samplesUntilEnd = fftSize - localPos;
            int samplesUntilFFT = hopSize - count;
            int chunk = std::min({ numSamples - i, samplesUntilEnd, samplesUntilFFT });
            std::copy(inBlock + i, inBlock + i + chunk, inputFifo.begin() + localPos);
            std::copy(outputFifo.begin() + localPos, outputFifo.begin() + localPos + chunk, outBlock + i);
            std::fill(outputFifo.begin() + localPos, outputFifo.begin() + localPos + chunk, 0.0f);
            localPos = (localPos + chunk) & (fftSize - 1);
            pos = localPos;
            count += chunk;
            i += chunk;
            if (count >= hopSize)
            {
                count = 0;
                processFrame(bypassed);
            }
        }
    }

    inline float processSample(float sample, bool bypassed)
    {
        float outSample = outputFifo[pos];
        inputFifo[pos] = sample;
        outputFifo[pos] = 0.0f;
        pos = (pos + 1) & (fftSize - 1);
        count = (count + 1) % hopSize;
        if (count == 0)
            processFrame(bypassed);
        return outSample;
    }

    inline std::vector<float> flushRemaining(bool bypassed)
    {
        std::vector<float> flushed;
        flushed.reserve(fftSize);
        for (int i = 0; i < fftSize; ++i)
            flushed.push_back(processSample(0.0f, bypassed));
        return flushed;
    }

    //==============================================================================
    // 2) Simple One-Shot Processing (unchanged)
    //==============================================================================
    inline std::vector<float> processEntireBuffer(const float* inData, int numSamples, bool bypassed)
    {
        reset();
        std::vector<float> out(numSamples + fftSize, 0.0f);
        processBlock(inData, out.data(), numSamples, bypassed);
        auto flushed = flushRemaining(bypassed);
        out.insert(out.end(), flushed.begin(), flushed.end());
        const int delay = fftSize - hopSize;
        const int totalOut = (int)out.size();
        const int trimmedLength = std::min(totalOut - delay, numSamples);
        std::vector<float> trimmed(trimmedLength, 0.0f);
        std::copy(out.begin() + delay, out.begin() + delay + trimmedLength, trimmed.begin());
        return trimmed;
    }

    //==============================================================================
    // 3) Offline STFT Workflow (advanced additive re-synthesis)
    //==============================================================================
    // SpectralFrame holds the amplitude and phase for each FFT bin.
    struct SpectralFrame
    {
        std::vector<float> amplitude;
        std::vector<float> phase;
    };

    // Optional user callback for spectral modifications.
    std::function<void(std::vector<SpectralFrame>& frames)> offlineTransformCallback;
    inline void setOfflineTransformCallback(std::function<void(std::vector<SpectralFrame>&)> cb)
    {
        offlineTransformCallback = cb;
    }

    // Top-level offline function.
    // This version normalizes the final output to match the RMS level of the input.
    inline std::vector<float> processOfflineBufferWithSTFT(const float* inData, int numSamples, bool bypassed)
    {
        if (numSamples <= 0)
            return std::vector<float>();
        auto frames = stftAnalyzeFullBuffer(inData, numSamples);
        std::vector<float> out;
        if (!bypassed)
        {
            if (offlineTransformCallback)
            {
                offlineTransformCallback(frames);
                out = stftSynthesizeFullBuffer(frames, numSamples);
            }
            else
            {
                // Global tracking with density balancing.
                // Allow partials to persist up to 86 frames (~1 sec at 44.1 kHz, hop=512)
                // and use a gentle decayFactor of 0.99.
                // The maxPartials parameter determines the maximum number of trajectories to retain.
                out = stftApplyAdditiveResynthesis(frames, additivePeakThreshold,
                    0.5f * additivePeakThreshold, 86, 0.99f,
                    maxPartials, numSamples);
            }
        }
        else
        {
            out = stftSynthesizeFullBuffer(frames, numSamples);
        }
        // Compute RMS of original input.
        float origRMS = 0.0f;
        for (int i = 0; i < numSamples; i++)
            origRMS += inData[i] * inData[i];
        origRMS = std::sqrt(origRMS / numSamples);

        // Compute RMS of synthesized output.
        float synthRMS = 0.0f;
        for (float v : out)
            synthRMS += v * v;
        synthRMS = std::sqrt(synthRMS / out.size());

        // Scale the synthesized output to match the RMS of the input.
        if (synthRMS > 0.0f)
        {
            float scaleFactor = origRMS / synthRMS;
            for (auto& v : out)
                v *= scaleFactor;
        }
        return out;
    }

private:
    //==============================================================================
    // Internal JUCE FFT objects.
    //==============================================================================
    juce::dsp::FFT fft;         // 2048-point FFT.
    juce::dsp::FFT fftPadded;     // 4096-point FFT (for zero-padding).

    //==============================================================================
    // Windowing.
    //==============================================================================
    std::vector<float> windowTable;     // Hann window.
    std::vector<float> compositeWindow; // Hann^2 with correction.

    //==============================================================================
    // Overlap-Add Circular Buffers.
    //==============================================================================
    std::array<float, fftSize> inputFifo{};
    std::array<float, fftSize> outputFifo{};

    //==============================================================================
    // Temporary Buffers.
    //==============================================================================
    std::vector<float> fftData;
    std::vector<float> paddedData;

    //==============================================================================
    // Internal State.
    //==============================================================================
    int pos;
    int count;
    float currentSampleRate;
    float lowpassCutoffFrequency;
    float additivePeakThreshold; // Base threshold for new partials.
    int   maxPartials;           // Maximum number of partials to track (3 to 200).

    //==============================================================================
    // processFrame: used by real-time overlap-add.
    //==============================================================================
    inline void processFrame(bool bypassed)
    {
        float* fptr = fftData.data();
        reassembleFFTFrame(fptr);
        std::memcpy(paddedData.data(), fptr, fftSize * sizeof(float));
        std::fill(paddedData.begin() + fftSize, paddedData.end(), 0.0f);
        juce::FloatVectorOperations::multiply(paddedData.data(), windowTable.data(), fftSize);
        if (!bypassed)
        {
            fftPadded.performRealOnlyForwardTransform(paddedData.data(), true);
            processSpectrumRealtime(paddedData.data(), paddedNumBins);
            fftPadded.performRealOnlyInverseTransform(paddedData.data());
        }
        juce::FloatVectorOperations::multiply(paddedData.data(), compositeWindow.data(), fftSize);
        if (pos > 0)
            juce::FloatVectorOperations::add(outputFifo.data(),
                paddedData.data() + fftSize - pos,
                pos);
        int remaining = fftSize - pos;
        if (remaining > 0)
            juce::FloatVectorOperations::add(outputFifo.data() + pos,
                paddedData.data(),
                remaining);
    }

    inline void processSpectrumRealtime(float* data, int nBins)
    {
        auto* cdata = reinterpret_cast<std::complex<float>*>(data);
        int cutoffBin = frequencyToBin(lowpassCutoffFrequency);
        for (int i = 0; i < nBins; ++i)
        {
            float mag = std::abs(cdata[i]);
            float ph = std::arg(cdata[i]);
            if (i > cutoffBin)
                mag = 0.0f;
            cdata[i] = std::polar(mag, ph);
        }
    }

    inline void reassembleFFTFrame(float* dest)
    {
        for (int i = 0; i < fftSize; ++i)
            dest[i] = inputFifo[(pos + i) & (fftSize - 1)];
    }

    inline int frequencyToBin(float frequency) const
    {
        int bin = int((frequency * paddedSize) / currentSampleRate + 0.5f);
        if (bin >= paddedNumBins) bin = paddedNumBins - 1;
        if (bin < 0) bin = 0;
        return bin;
    }

    //==============================================================================
    // Offline STFT Analysis and Conventional Synthesis.
    //==============================================================================
    inline std::vector<SpectralFrame> stftAnalyzeFullBuffer(const float* inData, int numSamples)
    {
        int totalFrames = (numSamples + hopSize - 1) / hopSize;
        std::vector<SpectralFrame> frames;
        frames.reserve((size_t)totalFrames);
        std::vector<float> frameBuffer(fftSize, 0.0f);
        for (int frameIndex = 0; frameIndex < totalFrames; ++frameIndex)
        {
            int frameStart = frameIndex * hopSize;
            int countToCopy = std::min(fftSize, numSamples - frameStart);
            if (countToCopy < 0)
                countToCopy = 0;
            std::fill(frameBuffer.begin(), frameBuffer.end(), 0.0f);
            if (countToCopy > 0)
                std::copy(inData + frameStart, inData + frameStart + countToCopy, frameBuffer.begin());
            std::fill(paddedData.begin(), paddedData.end(), 0.0f);
            for (int i = 0; i < fftSize; ++i)
                paddedData[i] = windowTable[i] * frameBuffer[i];
            fftPadded.performRealOnlyForwardTransform(paddedData.data(), true);
            SpectralFrame sf;
            sf.amplitude.resize(paddedNumBins);
            sf.phase.resize(paddedNumBins);
            auto* cdata = reinterpret_cast<std::complex<float>*>(paddedData.data());
            for (int b = 0; b < paddedNumBins; ++b)
            {
                sf.amplitude[b] = std::abs(cdata[b]);
                sf.phase[b] = std::arg(cdata[b]);
            }
            frames.push_back(sf);
        }
        return frames;
    }

    inline std::vector<float> stftSynthesizeFullBuffer(const std::vector<SpectralFrame>& frames, int originalLength)
    {
        if (frames.empty())
            return std::vector<float>();
        int totalFrames = (int)frames.size();
        std::vector<float> out((totalFrames - 1) * hopSize + fftSize + 8, 0.0f);
        for (int frameIndex = 0; frameIndex < totalFrames; ++frameIndex)
        {
            std::fill(paddedData.begin(), paddedData.end(), 0.0f);
            const auto& sf = frames[frameIndex];
            auto* cdata = reinterpret_cast<std::complex<float>*>(paddedData.data());
            int nbins = std::min<int>(paddedNumBins, (int)sf.amplitude.size());
            for (int b = 0; b < nbins; ++b)
                cdata[b] = std::polar(sf.amplitude[b], sf.phase[b]);
            fftPadded.performRealOnlyInverseTransform(paddedData.data());
            for (int i = 0; i < fftSize; ++i)
                paddedData[i] *= compositeWindow[i];
            int outPos = frameIndex * hopSize;
            for (int i = 0; i < fftSize; ++i)
                out[outPos + i] += paddedData[i];
        }
        if (originalLength > 0 && originalLength < (int)out.size())
            out.resize(originalLength);
        return out;
    }

    //==============================================================================
    // Advanced Additive Re-Synthesis with Global Tracking and Density Balancing.
    //
    // This function performs global tracking of partial trajectories.
    // It first detects peaks using quadratic interpolation, then prunes each frame's peaks
    // by dividing the spectrum into three bands (low, mid, high) and limiting the number of
    // peaks per band using fixed maximums (for lows, the maximum is set lower to avoid extra
    // low harmonics). Next, a greedy tracking algorithm links peaks across frames to form
    // trajectories ("snakes"). To favor early tracking, a trajectory is started at the first
    // frame in which a peak appears. Each trajectory is then scored using a frequency-weighted
    // sum (boosting high frequencies slightly) and only the top maxPartials trajectories are
    // retained. The amplitude envelope of each trajectory is smoothed with a moving average.
    // Finally, each trajectory is re-synthesized by linearly interpolating its frequency and
    // amplitude envelopes with continuous phase integration and a minimal fade (~5 ms) at its
    // boundaries. The output is then normalized (via RMS matching to the original input).
    //------------------------------------------------------------------------------
    inline std::vector<float> stftApplyAdditiveResynthesis(const std::vector<SpectralFrame>& frames,
        float startThresh, float continueThresh,
        int maxGap, float decayFactor,
        int maxPartialsParam, int originalLength)
    {
        // Step 1: Peak Detection.
        struct Peak { float freq; float amp; float phase; float bin; };
        std::vector< std::vector<Peak> > framePeaks(frames.size());
        for (size_t i = 0; i < frames.size(); ++i)
        {
            const auto& sf = frames[i];
            int nBins = (int)sf.amplitude.size();
            if (nBins < 3)
                continue;
            float maxAmp = *std::max_element(sf.amplitude.begin(), sf.amplitude.end());
            for (int b = 1; b < nBins - 1; ++b)
            {
                float beta = sf.amplitude[b];
                float alpha = sf.amplitude[b - 1];
                float gamma = sf.amplitude[b + 1];
                float p = 0.5f * (alpha - gamma) / (alpha - 2.0f * beta + gamma);
                float refinedBin = b + p;
                float freq = refinedBin * currentSampleRate / paddedSize;
                // For frequencies below 250 Hz, raise threshold to avoid extra low harmonics.
                float effThresh = startThresh * maxAmp;
                if (freq < 250.0f)
                    effThresh *= 2.0f * CULLING_LENIENCY;
                else
                    effThresh *= 0.8f * CULLING_LENIENCY; // be more lenient above 250 Hz
                if (beta < effThresh)
                    continue;
                if (beta >= sf.amplitude[b - 1] && beta >= sf.amplitude[b + 1])
                {
                    float ph = sf.phase[b];
                    framePeaks[i].push_back({ freq, beta, ph, refinedBin });
                }
            }
        }

        // Step 2: Density Balancing per Frame.
        auto balancePeaks = [&](std::vector<Peak>& peaks) -> std::vector<Peak> {
            std::vector<Peak> low, mid, high;
            for (auto& pk : peaks)
            {
                if (pk.freq < 250.0f)
                    low.push_back(pk);
                else if (pk.freq < 2000.0f)
                    mid.push_back(pk);
                else
                    high.push_back(pk);
            }
            int maxLow = 2;   // fixed maximum in lows
            int maxMid = 6;   // fixed maximum in mids
            int maxHigh = 10; // fixed maximum in highs
            auto prune = [&](std::vector<Peak>& band, int maxCount) {
                if (band.size() <= (size_t)maxCount)
                    return;
                std::sort(band.begin(), band.end(), [](const Peak& a, const Peak& b) { return a.amp > b.amp; });
                band.resize(maxCount);
                };
            prune(low, maxLow);
            prune(mid, maxMid);
            prune(high, maxHigh);
            std::vector<Peak> balanced;
            balanced.insert(balanced.end(), low.begin(), low.end());
            balanced.insert(balanced.end(), mid.begin(), mid.end());
            balanced.insert(balanced.end(), high.begin(), high.end());
            std::sort(balanced.begin(), balanced.end(), [](const Peak& a, const Peak& b) { return a.freq < b.freq; });
            return balanced;
            };
        for (size_t i = 0; i < framePeaks.size(); ++i)
            framePeaks[i] = balancePeaks(framePeaks[i]);

        // Step 3: Global Greedy Tracking.
        struct Trajectory {
            std::vector<int> frames;
            std::vector<float> freqs;
            std::vector<float> amps;
            std::vector<float> phases;
        };
        std::vector<Trajectory> trajs;
        float freqTolerance = 20.0f;
        std::vector<std::vector<bool>> used(framePeaks.size());
        for (size_t i = 0; i < framePeaks.size(); ++i)
            used[i] = std::vector<bool>(framePeaks[i].size(), false);
        int minDuration = 3;
        for (size_t i = 0; i < framePeaks.size(); ++i)
        {
            for (size_t j = 0; j < framePeaks[i].size(); ++j)
            {
                if (used[i][j])
                    continue;
                Trajectory traj;
                traj.frames.push_back((int)i);
                traj.freqs.push_back(framePeaks[i][j].freq);
                traj.amps.push_back(framePeaks[i][j].amp);
                traj.phases.push_back(framePeaks[i][j].phase);
                used[i][j] = true;
                float lastFreq = framePeaks[i][j].freq;
                for (size_t k = i + 1; k < framePeaks.size(); ++k)
                {
                    int bestIdx = -1;
                    float bestDiff = freqTolerance;
                    for (size_t m = 0; m < framePeaks[k].size(); ++m)
                    {
                        if (used[k][m])
                            continue;
                        float diff = std::fabs(framePeaks[k][m].freq - lastFreq);
                        if (diff < bestDiff)
                        {
                            bestDiff = diff;
                            bestIdx = (int)m;
                        }
                    }
                    if (bestIdx != -1)
                    {
                        traj.frames.push_back((int)k);
                        traj.freqs.push_back(framePeaks[k][bestIdx].freq);
                        traj.amps.push_back(framePeaks[k][bestIdx].amp);
                        traj.phases.push_back(framePeaks[k][bestIdx].phase);
                        used[k][bestIdx] = true;
                        lastFreq = framePeaks[k][bestIdx].freq;
                    }
                    else
                    {
                        traj.frames.push_back((int)k);
                        traj.freqs.push_back(lastFreq);
                        traj.amps.push_back(0.0f);
                        traj.phases.push_back(0.0f);
                    }
                }
                if ((int)traj.frames.size() >= minDuration)
                    trajs.push_back(traj);
            }
        }

        // Step 4: Filter trajectories by importance.
        std::vector<Trajectory> finalTrajs;
        float fmax = currentSampleRate / 2.0f;
        for (const auto& t : trajs)
        {
            float score = 0.0f;
            for (size_t i = 0; i < t.amps.size(); i++)
            {
                float weight = 1.0f;
                if (t.freqs[i] > 250.0f)
                    weight = 1.0f + 0.2f * ((t.freqs[i] - 250.0f) / (fmax - 250.0f));
                score += t.amps[i] * weight;
            }
            float scoreThresh = 30.0f;
            if (score >= scoreThresh)
                finalTrajs.push_back(t);
        }

        // Step 5: Sort trajectories by score and keep only the top maxPartials.
        std::vector<std::pair<Trajectory, float>> scoredTrajs;
        for (const auto& t : finalTrajs)
        {
            float score = 0.0f;
            for (size_t i = 0; i < t.amps.size(); i++)
            {
                float weight = (t.freqs[i] > 250.0f) ? (1.0f + 0.2f * ((t.freqs[i] - 250.0f) / (fmax - 250.0f))) : 1.0f;
                score += t.amps[i] * weight;
            }
            scoredTrajs.push_back(std::make_pair(t, score));
        }
        std::sort(scoredTrajs.begin(), scoredTrajs.end(), [](const std::pair<Trajectory, float>& a, const std::pair<Trajectory, float>& b)
            {
                return a.second > b.second;
            });
        int finalCount = std::min((int)scoredTrajs.size(), maxPartialsParam);
        std::vector<Trajectory> prunedTrajs;
        for (int i = 0; i < finalCount; i++)
            prunedTrajs.push_back(scoredTrajs[i].first);

        // Step 6: Smooth the amplitude envelope of each trajectory using a moving average.
        const int smoothWindow = 5;
        for (auto& t : prunedTrajs)
        {
            int N = (int)t.amps.size();
            std::vector<float> smoothAmp(N, 0.0f);
            for (int i = 0; i < N; i++)
            {
                float sum = 0.0f;
                int cnt = 0;
                for (int j = std::max(0, i - smoothWindow); j <= std::min(N - 1, i + smoothWindow); j++)
                {
                    sum += t.amps[j];
                    cnt++;
                }
                smoothAmp[i] = sum / cnt;
            }
            t.amps = smoothAmp;
        }

        // Step 7: Re-synthesis.
        int totalFrames = (int)frames.size();
        int totalLength = (totalFrames - 1) * hopSize + fftSize;
        std::vector<float> synth(totalLength, 0.0f);
        const float twoPi = 6.28318530717958647692f;
        for (const auto& t : prunedTrajs)
        {
            int startFrame = t.frames.front();
            int endFrame = t.frames.back();
            int startSample = (fftSize / 2) + startFrame * hopSize;
            int endSample = (fftSize / 2) + endFrame * hopSize;
            int trackLength = endSample - startSample;
            if (trackLength <= 0)
                continue;
            float phase = t.phases.front();
            for (int n = 0; n < trackLength; n++)
            {
                float tGlobal = n / (float)trackLength;
                float posF = tGlobal * ((int)t.amps.size() - 1);
                int idx0 = (int)std::floor(posF);
                int idx1 = std::min(idx0 + 1, (int)t.amps.size() - 1);
                float frac = posF - idx0;
                float freqInterp = t.freqs[idx0] * (1.0f - frac) + t.freqs[idx1] * frac;
                float ampInterp = t.amps[idx0] * (1.0f - frac) + t.amps[idx1] * frac;
                float dPhase = twoPi * freqInterp / currentSampleRate;
                phase += dPhase;
                int sampleIndex = startSample + n;
                if (sampleIndex < (int)synth.size())
                {
                    float fade = 1.0f;
                    int fadeSamples = std::min(64, trackLength / 10);
                    if (n < fadeSamples)
                        fade = n / (float)fadeSamples;
                    else if (n > trackLength - fadeSamples)
                        fade = (trackLength - n) / (float)fadeSamples;
                    synth[sampleIndex] += ampInterp * fade * std::cos(phase);
                }
            }
        }

        // Step 8: Normalize output to unity gain.
        float maxVal = 0.0f;
        for (float v : synth)
            maxVal = std::max(maxVal, std::fabs(v));
        if (maxVal > 0.0f)
        {
            for (auto& v : synth)
                v /= maxVal;
        }
        if (originalLength > 0 && originalLength < (int)synth.size())
            synth.resize(originalLength);
        return synth;
    }
};
