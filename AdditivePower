// ------------------------------
// GriffinFFT_UL.h
// FFT engine with enhanced FFT reassignment using cross‚Äêspectral integration,
// refined additive resynthesis, and with lowpass filtering removed so that
// high frequency partials are preserved.
// ------------------------------
#pragma once
#include <JuceHeader.h>
#include <array>
#include <vector>
#include <complex>
#include <functional>
#include <algorithm>
#include <cmath>
#include <cstring>

class GriffinFFT_UL
{
public:
    //------------------------------------------------------------------------------
    // Constants
    //------------------------------------------------------------------------------
    // Lower culling leniency to retain more small peaks.
    static constexpr float CULLING_LENIENCY = 0.1f;

    //==============================================================================
    // FFT / Overlap / Window Settings
    //==============================================================================
    static constexpr int fftOrder = 12;              // fftSize = 1 << fftOrder
    static constexpr int fftSize = 1 << fftOrder;
    static constexpr int overlap = 4;
    static constexpr int hopSize = fftSize / overlap;
    // Increase zero padding for improved time resolution in reassignment.
    static constexpr int zeroPadOrder = fftOrder + 2;
    static constexpr int paddedSize = 1 << zeroPadOrder;
    static constexpr int paddedNumBins = paddedSize / 2 + 1;
    static constexpr float windowCorrection = 2.0f / 3.0f;

    //==============================================================================
    // Public Parameter Setters
    //==============================================================================
    inline void setSampleRate(float sr) { currentSampleRate = sr; }
    inline void setLowpassCutoff(float /*freqHz*/) { /* Removed: not used */ }
    inline void setAdditivePeakThreshold(float thresh) { additivePeakThreshold = thresh; }
    inline void setMaxPartials(int m) { maxPartials = std::max(3, std::min(m, 200)); }

    //==============================================================================
    // Constructor
    //==============================================================================
    // Here we choose to use a Gaussian analysis window for better transient resolution.
    GriffinFFT_UL()
        : fft(fftOrder),
          fftPadded(zeroPadOrder),
          currentSampleRate(44100.0f),
          lowpassCutoffFrequency(5000.0f), // Unused in offline path.
          additivePeakThreshold(0.5f),
          maxPartials(60),
          pos(0),
          count(0),
          useGaussianWindow(true),
          sigma(0.3f)
    {
        windowTable.resize(fftSize);
        compositeWindow.resize(fftSize);
        derivWindow.resize(fftSize);
        timeWeightedWindow.resize(fftSize);

        // Choose window shape:
        for (int i = 0; i < fftSize; ++i)
        {
            if (useGaussianWindow)
            {
                // Gaussian window centered at (fftSize-1)/2
                float n = static_cast<float>(i);
                float center = (fftSize - 1) / 2.0f;
                windowTable[i] = std::exp(-0.5f * std::pow((n - center) / (sigma * center), 2.0f));
            }
            else
            {
                // Standard Hann window.
                windowTable[i] = 0.5f * (1.0f - std::cos((2.0f * 3.14159265358979323846f * i) / (fftSize - 1)));
            }
            compositeWindow[i] = windowTable[i] * windowTable[i] * windowCorrection;
            // Compute derivative window using finite differences.
            if (i == 0)
                derivWindow[i] = (windowTable[1] - windowTable[0]);
            else if (i == fftSize - 1)
                derivWindow[i] = (windowTable[fftSize - 1] - windowTable[fftSize - 2]);
            else
                derivWindow[i] = (windowTable[i + 1] - windowTable[i - 1]) * 0.5f;
            // Time-weighted window (for dt estimation)
            float tOffset = static_cast<float>(i) - float(fftSize) / 2.0f;
            timeWeightedWindow[i] = tOffset * windowTable[i];
        }
        inputFifo.fill(0.0f);
        outputFifo.fill(0.0f);
        fftData.resize(fftSize * 2, 0.0f);
        paddedData.resize(paddedSize * 2, 0.0f);
        paddedData_time.resize(paddedSize * 2, 0.0f);
        paddedData_deriv.resize(paddedSize * 2, 0.0f);
    }

    //==============================================================================
    // reset
    //==============================================================================
    inline void reset()
    {
        count = 0;
        pos = 0;
        inputFifo.fill(0.0f);
        outputFifo.fill(0.0f);
    }

    //==============================================================================
    // 1) Real-time Overlap-Add Usage (unchanged)
    //==============================================================================
    inline void processBlock(const float* inBlock, float* outBlock, int numSamples, bool bypassed)
    {
        int i = 0;
        while (i < numSamples)
        {
            int localPos = pos;
            int samplesUntilEnd = fftSize - localPos;
            int samplesUntilFFT = hopSize - count;
            int chunk = std::min({ numSamples - i, samplesUntilEnd, samplesUntilFFT });
            std::copy(inBlock + i, inBlock + i + chunk, inputFifo.begin() + localPos);
            std::copy(outputFifo.begin() + localPos, outputFifo.begin() + localPos + chunk, outBlock + i);
            std::fill(outputFifo.begin() + localPos, outputFifo.begin() + localPos + chunk, 0.0f);
            localPos = (localPos + chunk) & (fftSize - 1);
            pos = localPos;
            count += chunk;
            i += chunk;
            if (count >= hopSize)
            {
                count = 0;
                processFrame(bypassed);
            }
        }
    }

    inline float processSample(float sample, bool bypassed)
    {
        float outSample = outputFifo[pos];
        inputFifo[pos] = sample;
        outputFifo[pos] = 0.0f;
        pos = (pos + 1) & (fftSize - 1);
        count = (count + 1) % hopSize;
        if (count == 0)
            processFrame(bypassed);
        return outSample;
    }

    inline std::vector<float> flushRemaining(bool bypassed)
    {
        std::vector<float> flushed;
        flushed.reserve(fftSize);
        for (int i = 0; i < fftSize; ++i)
            flushed.push_back(processSample(0.0f, bypassed));
        return flushed;
    }

    //==============================================================================
    // 2) Simple One-Shot Processing (unchanged)
    //==============================================================================
    inline std::vector<float> processEntireBuffer(const float* inData, int numSamples, bool bypassed)
    {
        reset();
        std::vector<float> out(numSamples + fftSize, 0.0f);
        processBlock(inData, out.data(), numSamples, bypassed);
        auto flushed = flushRemaining(bypassed);
        out.insert(out.end(), flushed.begin(), flushed.end());
        const int delay = fftSize - hopSize;
        const int totalOut = static_cast<int>(out.size());
        const int trimmedLength = std::min(totalOut - delay, numSamples);
        std::vector<float> trimmed(trimmedLength, 0.0f);
        std::copy(out.begin() + delay, out.begin() + delay + trimmedLength, trimmed.begin());
        return trimmed;
    }

    //==============================================================================
    // 3) Offline STFT Workflow with FFT Reassignment.
    //==============================================================================
    // SpectralFrame holds amplitude, phase, and reassignment info.
    struct SpectralFrame
    {
        std::vector<float> amplitude;
        std::vector<float> phase;
        std::vector<float> timeReassign;
        std::vector<float> freqReassign;
    };

    // Optional user callback for spectral modifications.
    std::function<void(std::vector<SpectralFrame>& frames)> offlineTransformCallback;
    inline void setOfflineTransformCallback(std::function<void(std::vector<SpectralFrame>&)> cb)
    {
        offlineTransformCallback = cb;
    }

    // Top-level offline function using FFT reassignment.
    inline std::vector<float> processOfflineBufferWithSTFT(const float* inData, int numSamples, bool bypassed)
    {
        if (numSamples <= 0)
            return std::vector<float>();
        auto frames = stftAnalyzeFullBuffer(inData, numSamples);
        std::vector<float> out;
        if (!bypassed)
        {
            if (offlineTransformCallback)
            {
                offlineTransformCallback(frames);
                out = stftSynthesizeFullBuffer(frames, numSamples);
            }
            else
            {
                out = stftApplyAdditiveResynthesis(frames, additivePeakThreshold,
                    0.5f * additivePeakThreshold, 86, 0.99f,
                    maxPartials, numSamples);
            }
        }
        else
        {
            out = stftSynthesizeFullBuffer(frames, numSamples);
        }
        float origRMS = 0.0f;
        for (int i = 0; i < numSamples; i++)
            origRMS += inData[i] * inData[i];
        origRMS = std::sqrt(origRMS / numSamples);
        float synthRMS = 0.0f;
        for (float v : out)
            synthRMS += v * v;
        synthRMS = std::sqrt(synthRMS / out.size());
        if (synthRMS > 0.0f)
        {
            float scaleFactor = origRMS / synthRMS;
            for (auto& v : out)
                v *= scaleFactor;
        }
        return out;
    }

private:
    //==============================================================================
    // Internal JUCE FFT objects.
    //==============================================================================
    juce::dsp::FFT fft;
    juce::dsp::FFT fftPadded;

    //==============================================================================
    // Windowing.
    //==============================================================================
    std::vector<float> windowTable;
    std::vector<float> compositeWindow;
    std::vector<float> derivWindow;
    std::vector<float> timeWeightedWindow;
    // Option to choose Gaussian window for better transient capture.
    bool useGaussianWindow;
    float sigma;

    //==============================================================================
    // Overlap-Add Circular Buffers.
    //==============================================================================
    std::array<float, fftSize> inputFifo{};
    std::array<float, fftSize> outputFifo{};

    //==============================================================================
    // Temporary Buffers.
    //==============================================================================
    std::vector<float> fftData;
    std::vector<float> paddedData;
    std::vector<float> paddedData_time;
    std::vector<float> paddedData_deriv;

    //==============================================================================
    // Internal State.
    //==============================================================================
    int pos;
    int count;
    float currentSampleRate;
    float lowpassCutoffFrequency; // Not used in offline analysis.
    float additivePeakThreshold;
    int   maxPartials;

    //==============================================================================
    // processFrame: used by real-time overlap-add.
    //==============================================================================
    inline void processFrame(bool bypassed)
    {
        float* fptr = fftData.data();
        reassembleFFTFrame(fptr);
        std::memcpy(paddedData.data(), fptr, fftSize * sizeof(float));
        std::fill(paddedData.begin() + fftSize, paddedData.end(), 0.0f);
        juce::FloatVectorOperations::multiply(paddedData.data(), windowTable.data(), fftSize);
        if (!bypassed)
        {
            fftPadded.performRealOnlyForwardTransform(paddedData.data(), true);
            // Removed lowpass filtering here.
            // Previously, we would zero out bins above a cutoff.
            fftPadded.performRealOnlyInverseTransform(paddedData.data());
        }
        juce::FloatVectorOperations::multiply(paddedData.data(), compositeWindow.data(), fftSize);
        if (pos > 0)
            juce::FloatVectorOperations::add(outputFifo.data(),
                paddedData.data() + fftSize - pos,
                pos);
        int remaining = fftSize - pos;
        if (remaining > 0)
            juce::FloatVectorOperations::add(outputFifo.data() + pos,
                paddedData.data(),
                remaining);
    }

    inline void reassembleFFTFrame(float* dest)
    {
        for (int i = 0; i < fftSize; ++i)
            dest[i] = inputFifo[(pos + i) & (fftSize - 1)];
    }

    inline int frequencyToBin(float frequency) const
    {
        int bin = int((frequency * paddedSize) / currentSampleRate + 0.5f);
        if (bin >= paddedNumBins) bin = paddedNumBins - 1;
        if (bin < 0) bin = 0;
        return bin;
    }

    //==============================================================================
    // Offline STFT Analysis with FFT Reassignment using cross-spectral integration.
    //==============================================================================
    inline std::vector<SpectralFrame> stftAnalyzeFullBuffer(const float* inData, int numSamples)
    {
        int totalFrames = (numSamples + hopSize - 1) / hopSize;
        std::vector<SpectralFrame> frames;
        frames.reserve(totalFrames);
        std::vector<float> frameBuffer(fftSize, 0.0f);

        // Parameters for kernel integration over frequency bins.
        int kernelRadius = 1;  // Use one bin on each side.
        float sigma_k = 1.0f;  // Kernel width for frequency integration.

        for (int frameIndex = 0; frameIndex < totalFrames; ++frameIndex)
        {
            int frameStart = frameIndex * hopSize;
            int countToCopy = std::min(fftSize, numSamples - frameStart);
            std::fill(frameBuffer.begin(), frameBuffer.end(), 0.0f);
            if (countToCopy > 0)
                std::copy(inData + frameStart, inData + frameStart + countToCopy, frameBuffer.begin());
            std::fill(paddedData.begin(), paddedData.end(), 0.0f);
            std::fill(paddedData_time.begin(), paddedData_time.end(), 0.0f);
            std::fill(paddedData_deriv.begin(), paddedData_deriv.end(), 0.0f);
            for (int i = 0; i < fftSize; ++i)
            {
                paddedData[i] = windowTable[i] * frameBuffer[i];
                paddedData_time[i] = timeWeightedWindow[i] * frameBuffer[i];
                paddedData_deriv[i] = derivWindow[i] * frameBuffer[i];
            }
            fftPadded.performRealOnlyForwardTransform(paddedData.data(), true);
            fftPadded.performRealOnlyForwardTransform(paddedData_time.data(), true);
            fftPadded.performRealOnlyForwardTransform(paddedData_deriv.data(), true);
            SpectralFrame sf;
            sf.amplitude.resize(paddedNumBins);
            sf.phase.resize(paddedNumBins);
            sf.timeReassign.resize(paddedNumBins);
            sf.freqReassign.resize(paddedNumBins);
            auto* cdata = reinterpret_cast<std::complex<float>*>(paddedData.data());
            auto* cdata_time = reinterpret_cast<std::complex<float>*>(paddedData_time.data());
            auto* cdata_deriv = reinterpret_cast<std::complex<float>*>(paddedData_deriv.data());

            // For each frequency bin, perform a kernel integral over neighboring bins.
            for (int b = 0; b < paddedNumBins; ++b)
            {
                std::complex<float> X = cdata[b];
                float Xmag = std::abs(X);
                sf.amplitude[b] = Xmag;
                sf.phase[b] = std::arg(X);
                if (Xmag < 1e-6f)
                {
                    sf.timeReassign[b] = frameIndex * hopSize + fftSize / 2;
                    sf.freqReassign[b] = b * currentSampleRate / paddedSize;
                }
                else
                {
                    float num_t = 0.0f;
                    float num_f = 0.0f;
                    float den = 0.0f;
                    int bmin = std::max(0, b - kernelRadius);
                    int bmax = std::min(paddedNumBins - 1, b + kernelRadius);
                    for (int bp = bmin; bp <= bmax; bp++)
                    {
                        float weight = std::exp(-0.5f * std::pow((b - bp) / sigma_k, 2.0f));
                        std::complex<float> Xp = cdata[bp];
                        float XpMag = std::abs(Xp);
                        float localEnergy = XpMag * XpMag;
                        den += weight * localEnergy;
                        std::complex<float> Xp_time = cdata_time[bp];
                        std::complex<float> Xp_deriv = cdata_deriv[bp];
                        num_t += weight * std::real(Xp_time * std::conj(Xp));
                        num_f += weight * std::imag(Xp_deriv * std::conj(Xp));
                    }
                    float dt = (den > 0.0f) ? num_t / den : 0.0f;
                    float df = (den > 0.0f) ? num_f / (2.0f * 3.14159265f * den) : 0.0f;
                    sf.timeReassign[b] = frameIndex * hopSize + fftSize / 2 - dt;
                    sf.freqReassign[b] = (b * currentSampleRate / paddedSize) + df;
                }
            }
            frames.push_back(sf);
        }
        return frames;
    }

    inline std::vector<float> stftSynthesizeFullBuffer(const std::vector<SpectralFrame>& frames, int originalLength)
    {
        if (frames.empty())
            return std::vector<float>();
        int totalFrames = static_cast<int>(frames.size());
        std::vector<float> out((totalFrames - 1) * hopSize + fftSize + 8, 0.0f);
        for (int frameIndex = 0; frameIndex < totalFrames; ++frameIndex)
        {
            std::fill(paddedData.begin(), paddedData.end(), 0.0f);
            const auto& sf = frames[frameIndex];
            auto* cdata = reinterpret_cast<std::complex<float>*>(paddedData.data());
            int nbins = std::min<int>(paddedNumBins, static_cast<int>(sf.amplitude.size()));
            for (int b = 0; b < nbins; ++b)
                cdata[b] = std::polar(sf.amplitude[b], sf.phase[b]);
            fftPadded.performRealOnlyInverseTransform(paddedData.data());
            for (int i = 0; i < fftSize; ++i)
                paddedData[i] *= compositeWindow[i];
            int outPos = frameIndex * hopSize;
            for (int i = 0; i < fftSize; ++i)
                out[outPos + i] += paddedData[i];
        }
        if (originalLength > 0 && originalLength < static_cast<int>(out.size()))
            out.resize(originalLength);
        return out;
    }

    //==============================================================================
    // Advanced Additive Re-Synthesis with Global Tracking and Density Balancing,
    // using FFT reassignment for improved time accuracy and sharper transients.
    //==============================================================================
    inline std::vector<float> stftApplyAdditiveResynthesis(const std::vector<SpectralFrame>& frames,
        float startThresh, float continueThresh,
        int maxGap, float decayFactor,
        int maxPartialsParam, int originalLength)
    {
        // Peak structure now carries reassigned time.
        struct Peak { float freq; float amp; float phase; float time; };
        std::vector< std::vector<Peak> > framePeaks(frames.size());
        for (size_t i = 0; i < frames.size(); ++i)
        {
            const auto& sf = frames[i];
            int nBins = static_cast<int>(sf.amplitude.size());
            if (nBins < 1)
                continue;
            float maxAmp = *std::max_element(sf.amplitude.begin(), sf.amplitude.end());
            for (int b = 0; b < nBins; ++b)
            {
                float beta = sf.amplitude[b];
                float freq = sf.freqReassign[b];
                // Removed frequency-dependent threshold adjustment.
                float effThresh = startThresh * maxAmp;
                if (beta < effThresh)
                    continue;
                if (b > 0 && b < nBins - 1)
                {
                    if (!(beta >= sf.amplitude[b - 1] && beta >= sf.amplitude[b + 1]))
                        continue;
                }
                // Use reassigned time for peak position.
                framePeaks[i].push_back({ freq, beta, sf.phase[b], sf.timeReassign[b] });
            }
        }

        // Balance peaks across frequency bands per frame.
        auto balancePeaks = [&](std::vector<Peak>& peaks) -> std::vector<Peak> {
            std::vector<Peak> low, mid, high;
            for (auto& pk : peaks)
            {
                if (pk.freq < 250.0f)
                    low.push_back(pk);
                else if (pk.freq < 2000.0f)
                    mid.push_back(pk);
                else
                    high.push_back(pk);
            }
            int maxLow = 4, maxMid = 8, maxHigh = 16;
            auto prune = [&](std::vector<Peak>& band, int maxCount) {
                if (band.size() <= static_cast<size_t>(maxCount))
                    return;
                std::sort(band.begin(), band.end(), [](const Peak& a, const Peak& b) { return a.amp > b.amp; });
                band.resize(maxCount);
            };
            prune(low, maxLow); prune(mid, maxMid); prune(high, maxHigh);
            std::vector<Peak> balanced;
            balanced.insert(balanced.end(), low.begin(), low.end());
            balanced.insert(balanced.end(), mid.begin(), mid.end());
            balanced.insert(balanced.end(), high.begin(), high.end());
            std::sort(balanced.begin(), balanced.end(), [](const Peak& a, const Peak& b) { return a.freq < b.freq; });
            return balanced;
        };
        for (size_t i = 0; i < framePeaks.size(); ++i)
            framePeaks[i] = balancePeaks(framePeaks[i]);

        // Track partials using the reassigned time.
        struct Trajectory {
            std::vector<float> times;
            std::vector<float> freqs;
            std::vector<float> amps;
            std::vector<float> phases;
        };
        std::vector<Trajectory> trajs;
        float freqTolerance = 20.0f;
        std::vector<std::vector<bool>> used(framePeaks.size());
        for (size_t i = 0; i < framePeaks.size(); ++i)
            used[i] = std::vector<bool>(framePeaks[i].size(), false);
        int minDuration = 3;
        for (size_t i = 0; i < framePeaks.size(); ++i)
        {
            for (size_t j = 0; j < framePeaks[i].size(); ++j)
            {
                if (used[i][j])
                    continue;
                Trajectory traj;
                traj.times.push_back(framePeaks[i][j].time);
                traj.freqs.push_back(framePeaks[i][j].freq);
                traj.amps.push_back(framePeaks[i][j].amp);
                traj.phases.push_back(framePeaks[i][j].phase);
                used[i][j] = true;
                float lastFreq = framePeaks[i][j].freq;
                for (size_t k = i + 1; k < framePeaks.size(); ++k)
                {
                    int bestIdx = -1;
                    float bestDiff = freqTolerance;
                    for (size_t m = 0; m < framePeaks[k].size(); ++m)
                    {
                        if (used[k][m])
                            continue;
                        float diff = std::fabs(framePeaks[k][m].freq - lastFreq);
                        if (diff < bestDiff)
                        {
                            bestDiff = diff;
                            bestIdx = static_cast<int>(m);
                        }
                    }
                    if (bestIdx != -1)
                    {
                        traj.times.push_back(framePeaks[k][bestIdx].time);
                        traj.freqs.push_back(framePeaks[k][bestIdx].freq);
                        traj.amps.push_back(framePeaks[k][bestIdx].amp);
                        traj.phases.push_back(framePeaks[k][bestIdx].phase);
                        used[k][bestIdx] = true;
                        lastFreq = framePeaks[k][bestIdx].freq;
                    }
                    else
                    {
                        traj.times.push_back(static_cast<float>(k * hopSize + fftSize / 2));
                        traj.freqs.push_back(lastFreq);
                        traj.amps.push_back(0.0f);
                        traj.phases.push_back(0.0f);
                    }
                }
                if (static_cast<int>(traj.times.size()) >= minDuration)
                    trajs.push_back(traj);
            }
        }

        // Unwrap phase for each trajectory.
        for (auto& traj : trajs)
            traj.phases = unwrapPhase(traj.phases);

        // Select the strongest trajectories.
        std::vector<Trajectory> finalTrajs;
        float fmax = currentSampleRate / 2.0f;
        for (const auto& t : trajs)
        {
            float score = 0.0f;
            for (size_t i = 0; i < t.amps.size(); i++)
            {
                float weight = 1.0f; // No frequency-dependent weighting.
                score += t.amps[i] * weight;
            }
            if (score >= 30.0f)
                finalTrajs.push_back(t);
        }
        std::vector<std::pair<Trajectory, float>> scoredTrajs;
        for (const auto& t : finalTrajs)
        {
            float score = 0.0f;
            for (size_t i = 0; i < t.amps.size(); i++)
            {
                float weight = 1.0f;
                score += t.amps[i] * weight;
            }
            scoredTrajs.push_back(std::make_pair(t, score));
        }
        std::sort(scoredTrajs.begin(), scoredTrajs.end(), [](const std::pair<Trajectory, float>& a, const std::pair<Trajectory, float>& b)
        {
            return a.second > b.second;
        });
        int finalCount = std::min(static_cast<int>(scoredTrajs.size()), maxPartialsParam);
        std::vector<Trajectory> prunedTrajs;
        for (int i = 0; i < finalCount; i++)
            prunedTrajs.push_back(scoredTrajs[i].first);

        // Synthesize output using the reassigned times.
        int totalFrames = static_cast<int>(frames.size());
        int totalLength = (totalFrames - 1) * hopSize + fftSize;
        std::vector<float> synth(totalLength, 0.0f);
        const float twoPi = 6.28318530717958647692f;
        // For each partial, inject a sharp onset impulse and synthesize the continuation.
        for (const auto& t : prunedTrajs)
        {
            int onsetSample = static_cast<int>(std::round(t.times.front()));
            // Inject a transient impulse over 8 samples for a very sharp onset.
            int transientWidth = 8;
            float onsetAmp = t.amps.front();
            float onsetPhase = t.phases.front();
            for (int n = 0; n < transientWidth; n++)
            {
                int idx = onsetSample + n;
                if (idx >= 0 && idx < static_cast<int>(synth.size()))
                {
                    float env = 0.5f * (1.0f - std::cos(2.0f * 3.14159265f * n / (transientWidth - 1)));
                    synth[idx] += onsetAmp * env * std::cos(onsetPhase);
                }
            }
            // Synthesize the sustained portion using narrow interpolation.
            float startTimeF = t.times.front();
            float endTimeF = t.times.back();
            int startSample = static_cast<int>(std::floor(startTimeF));
            int endSample = static_cast<int>(std::ceil(endTimeF));
            int trackLength = endSample - startSample;
            if (trackLength <= 0)
                continue;
            float phase = t.phases.front();
            int trajPointIndex = 0;
            int fadeSamples = std::min(8, trackLength / 20); // Narrow fade window.
            for (int n = startSample; n < endSample; n++)
            {
                while (trajPointIndex < static_cast<int>(t.times.size()) - 1 && t.times[trajPointIndex + 1] < n)
                    trajPointIndex++;
                int i0 = trajPointIndex;
                int i1 = std::min(trajPointIndex + 1, static_cast<int>(t.times.size()) - 1);
                float t0 = t.times[i0], t1 = t.times[i1];
                float alpha = (t1 - t0) > 0.0f ? (n - t0) / (t1 - t0) : 0.0f;
                float freqInterp = t.freqs[i0] * (1.0f - alpha) + t.freqs[i1] * alpha;
                float ampInterp = t.amps[i0] * (1.0f - alpha) + t.amps[i1] * alpha;
                phase += twoPi * freqInterp / currentSampleRate;
                float fade = 1.0f;
                if (n - startSample < fadeSamples)
                    fade = (n - startSample) / static_cast<float>(fadeSamples);
                else if (endSample - n < fadeSamples)
                    fade = (endSample - n) / static_cast<float>(fadeSamples);
                if (n >= 0 && n < static_cast<int>(synth.size()))
                    synth[n] += ampInterp * fade * std::cos(phase);
            }
        }
        float maxVal = 0.0f;
        for (float v : synth)
            maxVal = std::max(maxVal, std::fabs(v));
        if (maxVal > 0.0f)
        {
            for (auto& v : synth)
                v /= maxVal;
        }
        if (originalLength > 0 && originalLength < static_cast<int>(synth.size()))
            synth.resize(originalLength);
        return synth;
    }

    //==============================================================================
    // Helper: Unwrap phase (applied across a trajectory's phase vector)
    //==============================================================================
    inline std::vector<float> unwrapPhase(const std::vector<float>& phases)
    {
        std::vector<float> unwrapped = phases;
        for (size_t i = 1; i < unwrapped.size(); i++)
        {
            float dp = unwrapped[i] - unwrapped[i - 1];
            while (dp > 3.14159265f)
            {
                unwrapped[i] -= 2.0f * 3.14159265f;
                dp = unwrapped[i] - unwrapped[i - 1];
            }
            while (dp < -3.14159265f)
            {
                unwrapped[i] += 2.0f * 3.14159265f;
                dp = unwrapped[i] - unwrapped[i - 1];
            }
        }
        return unwrapped;
    }
};
